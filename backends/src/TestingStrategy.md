# Backend Testing Strategy

## Overview
This document outlines the hybrid testing approach for inference engine backends, combining integration tests (real models) with unit tests (mocks) for maximum reliability and coverage.

## Testing Hierarchy

### 1. Mock-Based Unit Tests (Always Run)
- **Purpose**: Test individual component logic in isolation
- **Benefits**: Fast, reliable, no external dependencies
- **Coverage**: API contracts, error handling, edge cases
- **Implementation**: Uses `MockInferenceInterface` with Google Mock

### 2. Dummy Model Integration Tests (Fallback)
- **Purpose**: Test with minimal valid models when real models unavailable
- **Benefits**: Tests model loading/parsing without external dependencies
- **Coverage**: Model format validation, basic inference pipeline
- **Implementation**: Generated by `create_dummy_model()` function

### 3. Real Model Integration Tests (Preferred)
- **Purpose**: Full end-to-end validation with actual models
- **Benefits**: Tests real-world scenarios and performance
- **Coverage**: Complete inference pipeline, accuracy validation
- **Implementation**: Downloaded/generated models via `model_downloader.py`

## Test Execution Flow

```
1. Check for real model availability
   ├─ Available → Run integration tests with real model
   └─ Unavailable → Try dummy model generation
       ├─ Success → Run integration tests with dummy model
       └─ Failure → Run unit tests with mocks only

2. Always run mock-based unit tests (regardless of model availability)

3. Report results with clear indication of test type used
```

## Implementation Guidelines

### Backend Test Structure
Each backend should have tests following this pattern:

```cpp
class BackendHybridTest : public AtomicBackendTest {
    // Model discovery and fallback logic
    // Both integration and unit test methods
};

// Unit Tests (Mock-based)
TEST_F(BackendHybridTest, MockBasicInference) { /* Always passes */ }
TEST_F(BackendHybridTest, MockErrorHandling) { /* Always passes */ }

// Integration Tests (Model-dependent)
TEST_F(BackendHybridTest, RealModelInference) { /* Conditional execution */ }
TEST_F(BackendHybridTest, ModelLoadingValidation) { /* Conditional execution */ }
```

### Test Categories

1. **Atomic Unit Tests**: Test individual methods in isolation
2. **Integration Tests**: Test complete inference pipeline
3. **Error Handling Tests**: Test graceful failure scenarios
4. **Performance Tests**: Measure inference speed and memory usage

## Benefits of This Approach

- **Reliability**: Tests never fail due to missing models
- **Speed**: Mock tests execute instantly
- **Coverage**: Both unit and integration testing
- **CI/CD Friendly**: Works in any environment
- **Developer Friendly**: Easy local testing without setup

## Model Management

- **Real Models**: Downloaded via `model_downloader.py`
- **Dummy Models**: Generated via `create_dummy_model()`
- **Model Caching**: Models cached locally to avoid re-download
- **Cleanup**: Temporary models cleaned after tests
